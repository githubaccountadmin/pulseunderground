<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Underground</title>
    <link rel="icon" type="image/jpeg" href="image1.jpeg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        :root {
            --primary: #7c4dff;
            --primary-light: #b388ff;
            --bg-dark: #0d0b14;
            --bg-light: #13101c;
            --bg-lighter: #1a1327;
            --border: #2a2438;
            --text: #fff;
            --neon-glow: 0 0 5px var(--primary), 0 0 10px var(--primary), 0 0 15px var(--primary);
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            line-height: 1.5;
            font-size: 16px;
        }
        #app-container {
            display: flex;
            min-height: 100vh;
            max-width: 1280px;
            margin: 0 auto;
        }
        #sidebar-left, #sidebar-right {
            position: sticky;
            top: 0;
            height: 100vh;
            background: var(--bg-light);
            padding: 20px;
            overflow-y: auto;
        }
        #sidebar-left { width: 250px; border-right: 1px solid var(--border); }
        #sidebar-right { width: 300px; border-left: 1px solid var(--border); }
        .logo { display: block; margin: 0 auto 20px; width: 100px; }
        h1 { font-size: 24px; color: var(--primary-light); text-align: center; margin-bottom: 20px; }
        h3 { font-size: 18px; color: var(--primary-light); margin-bottom: 15px; }
        nav ul { list-style: none; }
        nav ul li { margin-bottom: 10px; }
        nav a {
            display: flex;
            align-items: center;
            color: var(--text);
            text-decoration: none;
            padding: 10px;
            border-radius: 8px;
            transition: background 0.2s, box-shadow 0.2s;
        }
        nav a:hover { background: var(--bg-lighter); box-shadow: var(--neon-glow); }
        .icon { width: 20px; height: 20px; margin-right: 15px; filter: drop-shadow(0 0 2px var(--primary)); }
        main {
            flex-grow: 1;
            width: calc(1280px - 550px);
            background: var(--bg-light);
            border: 1px solid var(--border);
            padding: 20px;
        }
        button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, var(--primary), var(--primary-light));
            color: var(--text);
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s, box-shadow 0.3s;
            margin-bottom: 15px;
        }
        button:hover { background: linear-gradient(45deg, #6a3fff, #a370ff); box-shadow: var(--neon-glow); }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        #publishStory {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #loadMoreButton {
            width: auto;
            padding: 8px 20px;
            font-size: 14px;
            margin: 20px auto;
            display: none;
        }
        #storySubmission {
            display: flex;
            padding: 15px;
            background: var(--bg-lighter);
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }
        .avatar { width: 48px; height: 48px; border-radius: 50%; margin-right: 15px; }
        .input-container { flex-grow: 1; position: relative; }
        textarea {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            background: var(--bg-light);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text);
            resize: none;
        }
        textarea:focus { outline: none; border-color: var(--primary); box-shadow: var(--neon-glow); }
        .news-item {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
        }
        .news-item:hover { background: var(--bg-lighter); }
        .reporter-info { display: flex; align-items: center; margin-bottom: 10px; }
        .reporter-details { font-size: 14px; margin-left: 10px; }
        .reporter-name { font-weight: bold; }
        .report-content { margin: 10px 0; line-height: 1.6; }
        #searchInput, #customChannelInput {
            width: 100%;
            padding: 12px 15px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: var(--text);
            margin-bottom: 20px;
        }
        #searchInput:focus, #customChannelInput:focus { outline: none; border-color: var(--primary); box-shadow: var(--neon-glow); }
        #loadingOverlay, #profileModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(13, 11, 20, 0.8);
            color: var(--text);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #statusMessage {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-light);
            padding: 10px 20px;
            border-radius: 5px;
            display: none;
            z-index: 1001;
            box-shadow: var(--neon-glow);
        }
        #channelSelection { margin-top: 20px; }
        #currentChannel { font-size: 14px; color: var(--text); margin-top: 10px; }
        .modal-content {
            background: var(--bg-light);
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            max-width: 90%;
            border: 1px solid var(--border);
        }
        .modal-content h2 { color: var(--primary-light); margin-bottom: 20px; }
        .modal-content label { display: block; margin-bottom: 10px; font-size: 14px; }
        .modal-content input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 5px;
            color: var(--text);
        }
        .modal-content img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin-bottom: 15px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        .modal-buttons { display: flex; gap: 10px; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar-left">
            <img src="image1.jpeg" alt="Pulse Underground Logo" class="logo">
            <nav>
                <ul>
                    <li><a href="#" id="homeLink"><span class="icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--primary-light)"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9z"></path><path d="M9 22V12h6v10"></path></svg></span>Home</a></li>
                    <li><a href="#"><span class="icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--primary-light)"><path d="M21 21l-6-6m2-5a7 7 0 1 0-14 0 7 7 0 0 0 14 0z"></path></svg></span>Explore</a></li>
                    <li><a href="#"><span class="icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--primary-light)"><path d="M12 22c5.5 0 10-4.5 10-10S17.5 2 12 2 2 6.5 2 12s4.5 10 10 10zM12 8v4M12 16h.01"></path></svg></span>Notifications</a></li>
                    <li><a href="#"><span class="icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--primary-light)"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg></span>Messages</a></li>
                    <li><a href="#" id="profileLink"><span class="icon"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="var(--primary-light)"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg></span>Profile</a></li>
                </ul>
            </nav>
            <button id="connectWallet">Connect Wallet</button>
            <div id="walletInfo" style="display: none;">
                <p>Connected: <span id="walletAddress"></span></p>
            </div>
        </div>
        <main>
            <h1>The Pulse Underground</h1>
            <div id="storySubmission">
                <img src="image1.jpeg" alt="User Avatar" class="avatar" id="submissionAvatar">
                <div class="input-container">
                    <textarea id="reportContent" placeholder="What's happening?"></textarea>
                    <button id="publishStory">➤</button>
                </div>
            </div>
            <div id="newsFeed"></div>
            <button id="loadMoreButton">Load More</button>
        </main>
        <div id="sidebar-right">
            <input type="text" id="searchInput" placeholder="Search The Pulse Underground">
            <div id="channelSelection">
                <h3>Channels</h3>
                <button id="mainChannel">Main Channel</button>
                <button id="selfChannel">Self Channel</button>
                <input type="text" id="customChannelInput" placeholder="Enter custom address">
                <button id="setCustomChannel">Set Custom Channel</button>
                <p>Current Channel: <span id="currentChannel"></span></p>
            </div>
            <div id="activeChannels">
                <h3>Active Channels</h3>
                <p>Coming soon...</p>
            </div>
        </div>
    </div>
    <div id="loadingOverlay">Loading...</div>
    <div id="statusMessage"></div>
    <div id="profileModal">
        <div class="modal-content">
            <h2>Edit Profile</h2>
            <img src="image1.jpeg" alt="Profile Preview" id="profilePicPreview">
            <label for="usernameInput">Username:</label>
            <input type="text" id="usernameInput" placeholder="Enter username">
            <label for="profilePicInput">Profile Picture URL:</label>
            <input type="text" id="profilePicInput" placeholder="Enter image URL">
            <div class="modal-buttons">
                <button id="saveProfile">Save</button>
                <button id="clearProfile">Clear Profile</button>
                <button id="closeProfileModal">Close</button>
            </div>
        </div>
    </div>

    <script>
        const ethers = window.ethers;
        const MAIN_CHANNEL = "0x9Cd83BE15a79646A3D22B81fc8dDf7B7240a62cB".toLowerCase();
        const PULSE_CHAIN_ID = 369;

        // Utilities
        const utils = {
            shortenAddress: addr => addr?.length > 10 ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : addr || "Unknown",
            formatDate: timestamp => new Date(timestamp).toLocaleString("en-US", {
                month: "short", day: "numeric", year: "numeric", hour: "2-digit", minute: "2-digit"
            }),
            showStatus: (msg, duration = 3000) => {
                const status = document.getElementById("statusMessage");
                status.textContent = msg;
                status.style.display = "block";
                setTimeout(() => status.style.display = "none", duration);
            },
            toggleLoading: show => document.getElementById("loadingOverlay").style.display = show ? "flex" : "none"
        };

        // IndexedDB Cache
        class Cache {
            constructor() {
                this.db = null;
                this.initDB();
            }
            initDB() {
                const request = indexedDB.open("PulseUndergroundCache", 2);
                request.onupgradeneeded = e => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains("newsItems")) {
                        db.createObjectStore("newsItems", { keyPath: "txHash" });
                    }
                    if (!db.objectStoreNames.contains("profiles")) {
                        db.createObjectStore("profiles", { keyPath: "address" });
                    }
                };
                request.onsuccess = () => this.db = request.result;
                request.onerror = () => utils.showStatus("IndexedDB Error");
            }
            async waitForDB() {
                if (!this.db) await new Promise(resolve => setTimeout(resolve, 100));
            }
            async getItems() {
                await this.waitForDB();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction("newsItems", "readonly");
                    const store = tx.objectStore("newsItems");
                    const req = store.getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            }
            async saveItems(items) {
                await this.waitForDB();
                const tx = this.db.transaction("newsItems", "readwrite");
                const store = tx.objectStore("newsItems");
                items.forEach(item => store.put(item));
                return new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });
            }
            async getProfile(address) {
                await this.waitForDB();
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction("profiles", "readonly");
                    const store = tx.objectStore("profiles");
                    const req = store.get(address);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
            }
            async saveProfile(profile) {
                await this.waitForDB();
                const tx = this.db.transaction("profiles", "readwrite");
                const store = tx.objectStore("profiles");
                store.put(profile);
                return new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });
            }
            async clearProfile(address) {
                await this.waitForDB();
                const tx = this.db.transaction("profiles", "readwrite");
                const store = tx.objectStore("profiles");
                store.delete(address);
                return new Promise((resolve, reject) => {
                    tx.oncomplete = resolve;
                    tx.onerror = () => reject(tx.error);
                });
            }
        }

        // Main Application
        class PulseUnderground {
            constructor() {
                this.state = {
                    newsItems: [],
                    searchTerm: "",
                    isLoading: false,
                    hasMore: true,
                    nextPageParams: null,
                    channel: MAIN_CHANNEL,
                    profile: { username: "", profilePicUrl: "image1.jpeg" },
                    signerAddress: null
                };
                this.elements = {
                    newsFeed: document.getElementById("newsFeed"),
                    reportContent: document.getElementById("reportContent"),
                    searchInput: document.getElementById("searchInput"),
                    loadMoreButton: document.getElementById("loadMoreButton"),
                    connectWallet: document.getElementById("connectWallet"),
                    walletInfo: document.getElementById("walletInfo"),
                    walletAddress: document.getElementById("walletAddress"),
                    publishStory: document.getElementById("publishStory"),
                    mainChannel: document.getElementById("mainChannel"),
                    selfChannel: document.getElementById("selfChannel"),
                    customChannelInput: document.getElementById("customChannelInput"),
                    setCustomChannel: document.getElementById("setCustomChannel"),
                    currentChannel: document.getElementById("currentChannel"),
                    submissionAvatar: document.getElementById("submissionAvatar"),
                    profileLink: document.getElementById("profileLink"),
                    profileModal: document.getElementById("profileModal"),
                    usernameInput: document.getElementById("usernameInput"),
                    profilePicInput: document.getElementById("profilePicInput"),
                    profilePicPreview: document.getElementById("profilePicPreview"),
                    saveProfile: document.getElementById("saveProfile"),
                    clearProfile: document.getElementById("clearProfile"),
                    closeProfileModal: document.getElementById("closeProfileModal")
                };
                this.cache = new Cache();
                this.signer = null;
                this.init();
            }
            async init() {
                await this.cache.saveItems([]);
                await this.loadCachedData();
                this.setupListeners();
                this.elements.currentChannel.textContent = utils.shortenAddress(this.state.channel);
                await this.fetchPosts(33);
            }
            setupListeners() {
                const { elements } = this;
                elements.connectWallet.addEventListener("click", () => this.toggleWallet());
                elements.publishStory.addEventListener("click", () => this.publishStory());
                elements.searchInput.addEventListener("input", this.debounce(() => {
                    this.state.searchTerm = elements.searchInput.value.trim().toLowerCase();
                    this.renderNewsFeed();
                }, 300));
                elements.loadMoreButton.addEventListener("click", () => this.onLoadMore());
                elements.homeLink.addEventListener("click", e => {
                    e.preventDefault();
                    window.scrollTo({ top: 0, behavior: "smooth" });
                });
                elements.mainChannel.addEventListener("click", () => this.setChannel(MAIN_CHANNEL));
                elements.selfChannel.addEventListener("click", async () => {
                    if (!this.signer) return utils.showStatus("Connect wallet first");
                    const address = await this.signer.getAddress();
                    this.setChannel(address.toLowerCase());
                });
                elements.setCustomChannel.addEventListener("click", () => {
                    const addr = elements.customChannelInput.value.trim().toLowerCase();
                    if (ethers.utils.isAddress(addr)) this.setChannel(addr);
                    else utils.showStatus("Invalid address");
                });
                elements.profileLink.addEventListener("click", e => {
                    e.preventDefault();
                    if (!this.signer) return utils.showStatus("Connect wallet first");
                    this.showProfileModal();
                });
                elements.saveProfile.addEventListener("click", () => this.saveProfile());
                elements.clearProfile.addEventListener("click", () => this.clearProfile());
                elements.closeProfileModal.addEventListener("click", () => elements.profileModal.style.display = "none");
                elements.profilePicInput.addEventListener("input", () => this.previewProfilePic());
            }
            debounce(fn, delay) {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => fn.apply(this, args), delay);
                };
            }
            async loadCachedData() {
                try {
                    this.state.newsItems = (await this.cache.getItems())
                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    this.renderNewsFeed();
                } catch {
                    utils.showStatus("Error loading cache");
                }
            }
            async toggleWallet() {
                this.signer ? await this.disconnectWallet() : await this.connectWallet();
            }
            async connectWallet() {
                try {
                    if (!window.ethereum) throw new Error("MetaMask not detected");
                    const provider = new ethers.providers.Web3Provider(window.ethereum);
                    if ((await provider.getNetwork()).chainId !== PULSE_CHAIN_ID) {
                        await window.ethereum.request({
                            method: "wallet_switchEthereumChain",
                            params: [{ chainId: "0x171" }]
                        });
                    }
                    await provider.send("eth_requestAccounts", []);
                    this.signer = provider.getSigner();
                    this.state.signerAddress = (await this.signer.getAddress()).toLowerCase();
                    this.elements.walletAddress.textContent = utils.shortenAddress(this.state.signerAddress);
                    this.elements.walletInfo.style.display = "block";
                    this.elements.connectWallet.textContent = "Disconnect Wallet";
                    await this.loadProfile();
                    utils.showStatus("Wallet connected");
                } catch (e) {
                    utils.showStatus("Connection failed: " + (e.message || "Unknown error"));
                }
            }
            async disconnectWallet() {
                this.signer = null;
                this.state.signerAddress = null;
                this.state.profile = { username: "", profilePicUrl: "image1.jpeg" };
                this.elements.walletInfo.style.display = "none";
                this.elements.connectWallet.textContent = "Connect Wallet";
                this.updateAvatars();
                utils.showStatus("Wallet disconnected");
            }
            async loadProfile() {
                try {
                    const profile = await this.cache.getProfile(this.state.signerAddress);
                    this.state.profile = profile || { username: "", profilePicUrl: "image1.jpeg" };
                    this.updateAvatars();
                } catch {
                    utils.showStatus("Error loading profile");
                }
            }
            async saveProfile() {
                const { usernameInput, profilePicInput } = this.elements;
                const username = usernameInput.value.trim();
                let profilePicUrl = profilePicInput.value.trim() || "image1.jpeg";
                if (profilePicUrl !== "image1.jpeg") {
                    try {
                        await new Promise((resolve, reject) => {
                            const img = new Image();
                            img.src = profilePicUrl;
                            img.onload = resolve;
                            img.onerror = () => reject(new Error("Invalid URL"));
                        });
                    } catch {
                        utils.showStatus("Invalid profile picture URL");
                        return;
                    }
                }
                this.state.profile = { username, profilePicUrl };
                await this.cache.saveProfile({ address: this.state.signerAddress, username, profilePicUrl });
                this.updateAvatars();
                this.elements.profileModal.style.display = "none";
                utils.showStatus("Profile saved");
            }
            async clearProfile() {
                await this.cache.clearProfile(this.state.signerAddress);
                this.state.profile = { username: "", profilePicUrl: "image1.jpeg" };
                this.updateAvatars();
                this.elements.profileModal.style.display = "none";
                utils.showStatus("Profile cleared");
            }
            showProfileModal() {
                const { usernameInput, profilePicInput, profilePicPreview, profile } = this.state;
                usernameInput.value = profile.username;
                profilePicInput.value = profile.profilePicUrl !== "image1.jpeg" ? profile.profilePicUrl : "";
                profilePicPreview.src = profile.profilePicUrl;
                this.elements.profileModal.style.display = "flex";
            }
            previewProfilePic() {
                const url = this.elements.profilePicInput.value.trim() || "image1.jpeg";
                const img = new Image();
                img.src = url;
                img.onload = () => this.elements.profilePicPreview.src = url;
                img.onerror = () => this.elements.profilePicPreview.src = "image1.jpeg";
            }
            updateAvatars = () => {
                this.elements.submissionAvatar.src = this.state.profile.profilePicUrl;
                this.renderNewsFeed();
            }
            async publishStory() {
                if (!this.signer) return utils.showStatus("Connect wallet first");
                const content = this.elements.reportContent.value.trim();
                if (!content) return utils.showStatus("Content cannot be empty");
                utils.toggleLoading(true);
                try {
                    const inputData = ethers.utils.hexlify(ethers.utils.toUtf8Bytes(content));
                    const tx = await this.signer.sendTransaction({
                        to: this.state.channel,
                        value: 0,
                        data: inputData,
                        gasLimit: 150000
                    });
                    const receipt = await tx.wait();
                    const newItem = {
                        content,
                        reporter: this.state.signerAddress,
                        timestamp: new Date().toISOString(),
                        txHash: receipt.transactionHash
                    };
                    this.state.newsItems.unshift(newItem);
                    await this.cache.saveItems([newItem]);
                    this.renderNewsFeed();
                    this.elements.reportContent.value = "";
                    utils.showStatus("Story published: " + utils.shortenAddress(receipt.transactionHash));
                } catch (e) {
                    utils.showStatus("Publish failed: " + (e.message || "Unknown error"));
                } finally {
                    utils.toggleLoading(false);
                }
            }
            async fetchOnePage() {
                if (!this.state.hasMore || !this.state.channel) return [];
                const url = `https://api.scan.pulsechain.com/api/v2/addresses/${this.state.channel}/transactions?limit=33${this.state.nextPageParams ? "&" + new URLSearchParams(this.state.nextPageParams) : ""}`;
                try {
                    console.log("Fetching:", url);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`API error: ${res.status}`);
                    const data = await res.json();
                    const items = this.parseTransactions(data.items || []);
                    this.state.nextPageParams = data.next_page_params;
                    this.state.hasMore = !!data.next_page_params && items.length > 0;
                    console.log("Fetched:", items.length, "nextPageParams:", this.state.nextPageParams, "hasMore:", this.state.hasMore);
                    return items;
                } catch (e) {
                    this.state.hasMore = false;
                    console.error("Fetch error:", e.message);
                    utils.showStatus("Fetch failed: " + (e.message || "Unknown error"));
                    return [];
                }
            }
            async fetchPosts(targetPosts) {
                if (this.state.isLoading || !this.state.channel) return utils.showStatus("No channel selected");
                this.state.isLoading = true;
                this.elements.loadMoreButton.disabled = true;
                utils.toggleLoading(true);
                try {
                    console.log("Fetch posts, target:", targetPosts, "current:", this.state.newsItems.length);
                    const needed = targetPosts - this.state.newsItems.length;
                    if (needed <= 0) {
                        this.state.hasMore = false;
                        return;
                    }
                    const newPosts = await this.fetchOnePage();
                    const uniqueNewPosts = newPosts
                        .filter(post => !this.state.newsItems.some(item => item.txHash === post.txHash))
                        .slice(0, needed);
                    console.log("Fetched:", newPosts.length, "Added:", uniqueNewPosts.length);
                    if (!uniqueNewPosts.length && !this.state.nextPageParams) {
                        this.state.hasMore = false;
                    }
                    this.state.newsItems = [...this.state.newsItems, ...uniqueNewPosts]
                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                        .filter((item, i, self) => i === self.findIndex(x => x.txHash === item.txHash));
                    await this.cache.saveItems(uniqueNewPosts);
                    this.renderNewsFeed();
                    if (this.state.newsItems.length < targetPosts && !this.state.hasMore) {
                        utils.showStatus("No more transactions found");
                    }
                } catch (e) {
                    console.error("Fetch error:", e.message);
                    utils.showStatus("Fetch failed: " + (e.message || "Unknown error"));
                } finally {
                    this.state.isLoading = false;
                    this.elements.loadMoreButton.disabled = false;
                    utils.toggleLoading(false);
                }
            }
            parseTransactions(transactions) {
                return transactions
                    .filter(tx => tx.raw_input && tx.raw_input !== "0x")
                    .map(tx => {
                        try {
                            const content = ethers.utils.toUtf8String(tx.raw_input).trim();
                            return content.length ? {
                                content,
                                reporter: tx.from?.hash || tx.from,
                                timestamp: tx.timestamp || new Date().toISOString(),
                                txHash: tx.hash
                            } : null;
                        } catch {
                            return null;
                        }
                    })
                    .filter(Boolean);
            }
            async onLoadMore() {
                if (this.state.hasMore && !this.state.isLoading) {
                    console.log("Load more, target:", this.state.newsItems.length + 33);
                    await this.fetchPosts(this.state.newsItems.length + 33);
                } else if (!this.state.hasMore) {
                    window.scrollTo({ top: 0, behavior: "smooth" });
                }
            }
            async setChannel(address) {
                this.state.channel = address.toLowerCase();
                this.state.newsItems = [];
                this.state.nextPageParams = null;
                this.state.hasMore = true;
                await this.cache.saveItems([]);
                this.renderNewsFeed();
                this.elements.currentChannel.textContent = utils.shortenAddress(this.state.channel);
                console.log("Set channel:", address, "fetching 33 posts");
                await this.fetchPosts(33);
            }
            renderNewsFeed() {
                const { newsFeed, searchTerm, newsItems, signerAddress, profile } = this.state;
                const items = searchTerm
                    ? newsItems.filter(item =>
                        item.content.toLowerCase().includes(searchTerm) ||
                        item.reporter.toLowerCase().includes(searchTerm))
                    : newsItems;
                newsFeed.innerHTML = items.length ? "" : "No news items available.";
                const fragment = document.createDocumentFragment();
                items.forEach(item => {
                    const div = document.createElement("div");
                    div.className = "news-item";
                    const isUser = item.reporter.toLowerCase() === signerAddress;
                    div.innerHTML = `
                        <div class="reporter-info">
                            <img src="${isUser && profile.profilePicUrl ? profile.profilePicUrl : "image1.jpeg"}" alt="Reporter" class="avatar">
                            <div class="reporter-details">
                                <span class="reporter-name">${isUser && profile.username ? profile.username : utils.shortenAddress(item.reporter)}</span> · ${utils.formatDate(item.timestamp)}
                            </div>
                        </div>
                        <div class="report-content">${item.content.replace(/\n/g, "<br>")}</div>
                    `;
                    fragment.appendChild(div);
                });
                newsFeed.appendChild(fragment);
                this.updateLoadMoreButton();
            }
            updateLoadMoreButton() {
                const { loadMoreButton, newsItems, hasMore, isLoading } = this.state;
                if (newsItems.length) {
                    loadMoreButton.style.display = "block";
                    loadMoreButton.textContent = hasMore ? "Load More" : "Return to Top";
                    loadMoreButton.disabled = isLoading;
                    console.log("Button state, hasMore:", hasMore, "isLoading:", isLoading);
                } else {
                    loadMoreButton.style.display = "none";
                }
            }
        }

        new PulseUnderground();
    </script>
</body>
</html>
